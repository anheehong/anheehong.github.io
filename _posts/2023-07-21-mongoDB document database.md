---
title: mongoDB document database
author: heehong
date: 2023-07-21 19:00:00 +0800
categories: [mongoDB]
tags: [데이터베이스, noSql, mongoDB, document, 몽고디비 인 액션]
published: true
---
# MongoDB에 대해서..

## document database
```json
{
    "_id": 10,
    "username": "peter",
    "email": [
        "pbbakkum@gmail.com",
        "pbb7c@virginia.edu"
    ]
}
```

mongoDB의 document 형식은 임의의 데이터 구조를 저장하는 스키마로 잘 알려진 JSON에 기반한다.
JSON 구조는 key, value 로 이루어져 있고, 중첩에 제한이 없다.
프로그래밍 언어에서 사전(dictionart)이나 해시 맵(hash map)과 유사하다.

document 기반의 데이터 모델은 풍부하고 계층적인 구조의 데이터를 표현할 수 있다. 따라서 관계 데이터베이스에서 필요한
여러 테이블 간의 복잡한 조인 연산이 없어도 된다.

### document 데이터 모델

mongoDB는 document 지항적인 데이터베이스다. 
```json
{
    "_id": "ObjectID(4bd9e8e17cefd644108961bb)",
    "title": "adventures in datebases",
    "url": "http://example.com/databases.txt",
    "author": "msmith",
    "vote_count": 20,
    "tags": ["databases", "mongodb", "indexing"],
    "image": {
        "url": "http://example.com/db/jpg",
        "caption": "A database",
        "type": "jpg",
        "size": 75381,
        "data": "Binary"
    }
    "comments": [
        {
            "user": "bjones",
            "text": "Interesting article"
        },
        {
            "user": "sverch",
            "text": "Color me skeptical!"
        }
    ]
}
```
document 는 본질적으로 속성의 이름과 값으로 이루어진 쌍의 집합이다.
속성의 값은 문자열이나 숫자, 날짜와 같이 간단한 데이터 타입이 될 수 있다.
하지만 이 값은 또한 배열이나 심지어 다른 JSON document가 될 수도 있다.
이러한 구성 요소들을 통해 하나의 document로 다양한 구조의 데이터를 표현 할 수 있다.

mongoDB가 document 의 모음과 같이 데이터를 collection에 document로 저장하는 반면, mysql은 데이터를 테이블에 행으로서 저장한다. 


### 스키마가 없는 모델의 장점
1. 데이터베이스가 아닌 애플리케이션이 데이터 구조를 정한다는 것이다. 데이터 구조가 빈번히 변경되는 개발 초기 단계에서 개발속도를 단축시켜 준다.
2. 스키마가 없는 데이터 모델을 통해 가변적인 속성을 갖는 데이터를 표현할 수 있다는 것이다.


### 인덱스
대부분의 데이터베이스는 각 document 또는 각 행에 기준을 위한 고유의 식별자로서 프라이머리 키를 부여한다. 프라이머리 키는 자동적으로 인덱스되어 각 기준은 유니크 키를 이용하여 효과적으로 기억되고, mongoDB 역시 같다.
하지만 모든 데이터베이스가 document 또는 행에 대한 인덱스 작업을 허용하는 것은 아니다. 이들은 세컨더리 인덱스라 부른다. 
**mongoDB는 여러개의 세컨더리 인덱스를 허용함으로써 사용자가 넓은 범위의 쿼리를 최적화하도록 허용한다.** 
한 collection에 64개까지 세컨더리 인덱스를 만들 수 있다. 오름차순, 내림차 순, 고유, 복합키, 해시, 텍스트, 심지어 지리공간적 인덱스와 같이 관계 데이터베이스 시스템에서 볼 수 있는 모든 인덱스가 가능하다.

>mongoDB에서 인덱스는 B-tree로 구현되어 있다.


### replica set
mongoDB는 replica set 이라고 부르는 구성을 통해 데이터베이스 복제 기능을 제공한다. 서버와 네트워크 장애가 발생할 경우를 대비해 중복성과 장애조치 자동화를 위해 데이터를 여러 대의 서버에 분산한다. 복제는 데이터베이스 읽기에 대한 확장을 위해서도 사용된다.

mongoDB 서버는 노드라 부른다. 하나의 노드는 replica set의 프라이머리 노드로 존재하며, 더불어 하나 또는 그 이상의 세컨더리 노드가 존재한다. 프라이머리 노드에 대해서는 읽기와 쓰기가 모두 가능하지만, 세컨더리 노드는 읽기만 가능하다. 
replica set의 고유한 기능은 **자동장애 조치**를 지원한다는 점이다. 프라이머리 노드에 장애가 발생하면 클러스터는 자동으로 세컨더리 가운데 하나를 선택해서 프라이머리로 성정한다. 이전의 프라이머리 노드가 복구되면 세컨더리 노드로 작동한다.

![replica_set.png](/assets/img/post//2023-07-21-mongoDB document database/replica_set.png)

### 속도와 내구성
쓰기 속도는 미리 정해진 시간 내에 데이터베이스가 얼마나 많은 수의 삽입, 수정, 삭제 명령을 처리할 수 있는가 를 뜻한다.
내구성은 쓰기 연산이 디스크에 제대로 이루어졌다는 것을 확신할 수 있는 정도를 뜻한다.

mongoDB의 경우에는 write semantics 와 journaling 을 통해 속도와 내구성사이에서 타협이 가능하다.

**journaling** 은 모든 쓰기에 대한 로그를 100ms 마다 한 번씩 저널 파일에 기록한다. 서버가 불시에 셧다운되면 저널의 mongoDB 파일을 복구해서 서버를 재시작할 때 원래의 상태를 유지하는데 이용된다. mongoDB 를 실행하는 가장 안전한 방법이다.

### 확장
대부분의 데이터베이스 시스템에서 확장을 위한 가장 쉬운 방법은 하드웨어를 업그레이드 하는 것이다. 애플리케이션이 하나의 데이터베이스 노드만을 가질 때 일반적인 경우는 디스크나 메모리 혹은 CPU를 추가하여 데이터베이스 병목현상을 완화시킬 수 있다.
하나의 노드에 대해 하드웨어를 업그레이드 하거나 추가함으로써 확장성을 높이는 것을 **수직적 확장** 혹은 **상향식 확장**이라고 한다. 수직적 확장은 간단하고 신뢰할 만하며 비용이 절감되는 장점은 있으나, 어느 정도 시점에 이르면 한계에 도달하여 더 이상 나은 장비로의 향상이 불가능하다.ㅂ

수평적 확장이란, 단 하나의 노드를 업그레이드하는 대신에 데이터베이스를 여러 대의 서버에 분산시키는 것을 뜻한다. 수평적으로 확장된 구조에서는 기존의 하드웨어를 사용할 수 있으므로 비용을 크게 절감할 수 있다. 더군다나 시스템에 장애가 발생해도 분산되 서버로 인해 장애에 따른 피해가 경감된다. 

![scaling.png](/assets/img/post//2023-07-21-mongoDB document database/expand.png)

mongoDB는 수평적 확장이 용이하도록 설계되었다. 샤딩으로 알려진 범위 기반 파티션 메커니즘을 통해 데이터를 여러 노드에 걸쳐 분산하는 것을 자동으로 관리해 준다. 샤딩 시스템은 샤드 노드를 추가해서 용량을 필요한 만큼 늘리고 자동 장애조치 기능도 제공한다. 
각각의 샤드는 최소한 두개의 노드로 구성된 replica set으로 이루어져 있어서 어느 한 노드에서도 장애가 발생하지 않은 채 자동으로 복구되도록 보장한다. 

### mongoDB 코어 서버와 셸
코어 데이터베이스 서버는 mongod 라는 실행 프로그램을 통해 구동된다. mongod 프로세스는 특별히 만들어진 바이너리 프로토콜을 통해 네트워크 소켓으로 명령을 받아들인다. mongod 프로세스의 데이터 파일은 모두 같은 서버에 저장되고, 저장되는 위치는 유닉스와 같은 시스템에서는 /data/db 에, 윈도우에서는 c:\data\db 로 기본 설정이 되어 있다. 

mongod는 독립 모드나 replica set 의 구성원과 같이 여러가지 모드로 실행될 수 있다. mongoDB를 상용에서 구동할 떄는 복제가 권장사항이며, 두 개의 복제 노드와 아비터모드로 구동하는 mongod로 이루어진 replica set이 일반적이다.

mongoDB 명령어 셸은 자바스크립트에 기반한 툴인데, 데이터베이스를 관리하고 데이터를 조작하는데 사용한다. mongo 실행파일은 셸을 로드하고 지정된 mongod 프로세스 또는 기본적으로 로컬에 구동되는 프로세스에 연결한다. 셸은 mysql 셸과 비슷하지만, 가장 큰 차이점은 명령어를 SQL 대신 자바스크립트로 표현한다는 것이다.

```javascript
use my_database
db.users.insert({name: "kyle"})

db.users.find(){ _id: ObjectId("4ba667b0a90578631c9caea0"), name: "kyle"}
```

- **mongodump, mongostore**: 데이터베이스 백업과 복구, bson 형태로 데이터를 저장
- **mongoexport, mongoimport**: json, csv, tsv 타입의 데이터를 export, import 
- **mongosniff**: bson을 읽기 쉬운 셸 문장으로 변환해준다.
- **mongostat**: mongoDB와 시스템을 계속 polling 해서 초당 수행되는 삽입, 질의, 수정, 삭제 등과 같은 연산의 수나 할당된 가상 메모리의 양이나 서버에 대한 연결의 수와 같이 유용한 통계 데이터를 제공해준다.
- **mongostop**: mongoDB와 시스템을 polling 해서 각 collection의 데이터를 읽고 쓰는 데 걸린 시간의 양을 보여준다.
- **mongoperf**: mongoDB 인스턴스가 구동되고 있을 때 발생하는 디스크 오퍼레이션을 이해하는데 도움을 준다.
- **mongooplog**: mongoDB oplog에서 어떤 일이 발생하고 있는지를 보여준다.
- **bsondump**: bson파일을 json을 비롯해 사람이 읽을 수 있는 형태로 변환해 준다.


### mongoDB를 사용하는 이유
mongoDB는 관계 데이터베이스와 키-값 저장 시스템의 장점만을 모아서 설계되었다. **키-값 저장 시스템**은 시스템의 단순성으로 인해 **속도가 매우 빠르고 확장도 상대적으로 용이하다**. 관계 데이터베이스는 수평적인 확장은 어려운 반면에 **다양 데이터 모델과 강력한 쿼리 언어**를 가지고 있다. 
mongoDB는 웹 애플리케이션, 분석과 로깅 애플리케이션, 캐시를 필요로 하는 일차 데이터 저장 시스템으로 적합하다.
스키마가 존재하지 않는 데이터를 저장하기가 용이하므로 미리 구조가 알려지지 않은 데이터를 저장하는데 유용하다.


### 관계 데이터베이스
mongoDB와 관계 데이터베이스는 둘 다 다양한 데이터 모델을 표현할 수 있다. 관계 데이터베이스가 고정된 스키마 테이블을 사용하는 반면에 mongoDB는 스키마가 없는 document를 사용한다. 대부분의 관계 데이터베이스는 세컨더리 인덱스와 집계를 지원한다.
관계 데이터베이스의 가장 결정적인 특징은 쿼리 언어로서 SQL의 사용이다. SQL은 데이터 작업하기에 매우 강력한 도구이다. SQL은 데이터베이스 간에 이식성이 꽤 좋은 편이다. 


### 사용 예와 배포
mongoDB는 웹어플리케이션에서 일차적 데이터 저장 시스템으로 사용하기에 적당하다. 도메인, 사용자 관리, 세션, 특정 어플리케이션에서 필요한 데이터, 업로드, 퍼미션 등을 위해 수많은 데이터 모델이 필요하다. document 는 다양한 구조의 데이터를 표현할 수 있으므로 필요한 collection 의 수는 동일한 데이터를 완전히 정규화된 관계 모델로 표현할 때 필요한 테이블의 수보다 훨씬 적다. 또한 동적 쿼리와 세컨더리 인덱스를 통해 SQL 개발자들에게 친숙한 대부분의 쿼리 언어를 쉽게 구현할 수 있다. 
웹 애플리케이션이 커져 감에 따라 필요한 확장성을 제공한다.

>mongoDB는 고정된 스키마가 없기 때문에 스키마를 적용시키고, 의논하고, 수정된 스키마를 반영하는데 들어가는 시간이 절약된다.
>이에 더해 관계 데이터 표현을 객체지향 모델로 끼워 맞추거나 생각하지 못한 부분을 다루는 데 들어가는 시간과 객체-지향 매핑(ORM)>기술에 의해 생성된 SQL을 최적화 하는데 들어가는 시간이 절감된다.

### 분석과 로깅
mongoDB가 분석에 적합한 것은 속도, 그리고 타킷 원자적 업데이트와 캡드 컬렉션이라는 두 가지 핵심적인 특징 때문이다. 원자적 업데이트를 통해 클라이언트는 카운터의 값을 효율적으로 증가하고 값을 배열에 푸시할 수 있게 된다. 캡드 컬렉션은 로깅에 유용한데, 캡드 컬렉션이 가장 최근의 document만을 저장하기 때문이다. 데이터를 구조화하기가 더 쉽고 더 강력한 질의를 할 수 있다는 장점이 있다. grep이나 로그 검색 유틸리티를 쓰지 않고도 mongoDB의 쿼리언어를 사용해서 로그 결과를 검사 할 수 있다.

### 팁과 한계
1. mongoDB는 보통 64비트 시스템에서 실행되어야 한다. 32비트 시스템은 4GB의 메모리만 쓸 수 있다. 메타데이터와 스토리지 오버헤드를 포함하는 데이터 세트가 4GB에 이르게 되면, 더 이상의 데이터를 저장할 수 없게 된다.

2. 가상 메모리 매핑을 사용해서 메모리를 자동으로 할당한다는 점이다. 데이터베이스를 공유 환경에서 실행하는 것이 더 까다로워진다.
mongoDB의 메모리 맵 파일 사용과 관련하야 데이터 세트를 질의할 때 메모리 스와핑이 발생하는 데이터에 대해 자주 디스크 접근을 요구한다. 작업 세트가 메모리를 초과하고 쿼리가 심각하게 느려지기 전까지는 좋다.

3. collection과 document를 저장하기 위해 사용하는 데이터 구조가 데이터 크기 관점에서는 그렇게 효율적이지 않다는 것이다. document 키를 각 document에 저장한다. username 이라는 필드 이름을 가진 모든 docuemnt가 필드 이름을 저장하기 위해 8바이트를 사용함을 뜻한다.

4. mongoDB 쿼리가 SQL만큼 친숙하거나 쉽지 않다는 것이며, mongoDB 쿼리는 일반적으로 SQL과 같은 텍스트 문자열이라기보다는 JSON 객체들의 구성이라 할수 있다. 이러한 구성은 중요한 고려사항이면서 프로그래밍적으로 쿼리를 생성하고 파싱하는데 간편함을 줄 수 있지만, 애드혹 쿼리를 변경하는 것은 더 어려울 수 있다.

5. 단일 노드의 로컬에서 실행해 보기에 매우 단순한 데이터베이스 중 하나이지만, 대규모의 클러스터를 운영하기 위한 유지비용이 발생할 수 있다. 분산 데이터베이스에서 발생하는 일로, 세 개의 환경설정 노드 클러스터를 요구하고 샤딩과 함께 각각 복제를 관리하는 mongoDB에서는 다소 예민한 문제이다.

6. replica set 의 샤드를 허용하는데, 데이터의 조각들이 오직 그 replica set 내에서만 복제됨을 뜻한다. 샤딩과 복제를 분리된 개념으로 유지하는 것은 그러한 장점이 있지만, 클러스터를 구성할 때 각각 설정되고 관리되어야 한다.


> 몽고 디비 인 액션을 참조하였습니다.
---
title: 객체지향 설계원칙
author: heehong
date: 2023-06-09 19:00:00 +0800
categories: [클린 소프트웨어]
tags: [객체지향, SOLID]
published: true
---

1. 경직성(Rigidity) : 설계를 변경하기 어려움 → 변경을 하려면 시스템의 다른 부분들까지 많이 변경해야 하기 때문이다.
2. 취약성(Fragility) : 설계가 망가지기 쉬움 → 변경을 하면 시스템에서 그 부분과 개념적으로 아무런 관련이 없는 부분이 망가진다.
3. 부동성(Immobility) : 설계를 재사용하기 어려움 → 시스템을 다른 시스템에서 재사용할 수 있는 컴포넌트로 구분하기가 어렵다.
4. 점착성(Viscosity) : 제대로 동작하기 어려움 → 옳은 동작을 하는 것이 잘못된 동작을 하는 것보다 더 어렵다.
5. 불필요한복잡성(Needles Complexity) : 과도한 설계 → 직접적인 효용이 전혀 없는 기반구조가 설계에 포함되어 있다.
6. 불필요한반복(Needless Repetition) : 마우스 남용 → 단일 추상 개념으로 통합할 수 있는 반복적인 구조가 설계에 포함되어 있다.
7. 불투명성(Opacity) : 혼란스러운 표현 → 읽고 이해하기 어렵다. 그 의도를 잘 표현하지 못한다.

> 그저 원칙이라는 이유만으로 무조건 따르는 것은 좋지 않다.

## SRP : 단일 책임 원칙(Single Responsibility principle)

**::한 클래스는 단 한 가지의 변경 이유만을 가져야 한다.::**

만약 한 클래스가 하나 이상의 책임을 맡는다면, 그 책임들은 결합된다. 한 책임에 대한 변경은 다른 책임을 충족시키는 클래스의 능력을 떨어뜨리거나 저하시킬 수도 있다. 이런 종류의 결함은 변경을 했을 때 예상치 못한 방식으로 잘못 동작하는 취약한 설계를 유발한다.

우리는 책임을 "변경을 위한 이유"로 정의한다.

만약 한 클래스를 변경하기 위한 한 가지 이상의 이유를 생각할 수 있아면, 그 클래스는 한 가지 이상의 책임을 맡고 있는 것이다.

## OCP : 개방 폐쇄 원칙(Open-closed Principle)

**::소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.::**

1. 확장에 대해 열려 있다.

   이것은 모듈의 행위가 확장될 수 있음을 의미한다. 애플리케이션의 요구사항이 변경될 때, 이 변경에 맞게 새로운 행위를 추가해 모듈을 확장할 수 있다. 즉, 모듈이 하는 일을 변경할 수 있다.

1. 수정에 대해 닫혀 있다.

   어떤 모듈의 행위를 확장하는 것이 그 모듈의 소스 코드나 바이너리 코드의 변경을 초래하지 않는다.

**해결책은 추상화다.**

고정되기는 해도 제한되지 않은 가능한 행위의 묶음을 표현하는 추상화를 만드는 것이 가능하다.

추상화는 추상 기반 클래스이자, 모든 가능한 파생 클래스를 대표하는 가능한 행위의 제한되지 않은 묶음이기도 하다.

모듈은 추상화를 조작할 수 있다. 이런 모듈은 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀 있을 수 있다. 그 모듈의 행위는 추상화의 새 파생 클래스들을 만듦으로써 확장이 가능하다.

![OCP_1.png](/assets/img/post//2023-06-09-객체지향 설계원칙/OCP_1.png)

![OCP_2.png](/assets/img/post//2023-06-09-객체지향 설계원칙/OCP_2.png)

## LSP : 리스코프 치환 원칙(Liskov substitution Principle)

**::서브타입(subtype)은 그것의 기반 타입(base type)으로 치환 가능해야 한다.::**

> 타입 S의 각 객체 A와 타입 T의 각 객체 B가 있을 때, T로 프로그램 P를 정의했음에도 불구하고, B를 A로 치환할 때 P의 행위가 변하지 않으면, S는 T의 서브타입이다

리스코프 치환 원칙은 개방 폐쇄 원칙을 가능하게 하는 주요 요인 중 하나다. 이것은 기반 타입으로 표현된 모듈을 수정 없이도 확장 가능하게 만드는, 서브타입의 치환 가능성을 말한다.

"IS-A"라는 용어는 서브타입의 정의가 되기에는 그 의미가 지나치게 넓다. 서브타입의 진실된 정의는 "치환 가능성"이다

## DIP : 의존 관계 역전 원칙(Dependency Inversion Principle)

1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
2. 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다.

상위 수준의 모듈이 하위 수준의 모듈에 의존할 때, 하위 수준 모듈의 변경은 상위 수준 모듈에 직접적인 영향을 미칠 수 있고, 상위 수준의 모듈이 변경되게 할 수도 있다.

하위 수준의 구체적인 모듈에 영향을 주어야 하는 것은 상위 수준의 모듈이다. 상위 수준의 모듈은 구체적인 구현을 포함한 모듈에 우선하면서 동시에 독립적이어야 한다. 독립적이라면, 상위 수준의 모듈은 아주 간단히 재사용할 수 있다.

**::상위 수준의 모듈은 어떤 식으로든 하위 수준의 모듈에 의존해서는 안된다.::**

## ISP : 인터페이스 분리 원칙(Interface segregation Principle)

**::클라이언트가 자신이 사용하지 않는 메소드에 의존하도록 강제되어서는 안된다.::**

클라이언트가 자신이 사용하지 않는 메소드에 의존하도록 강제될 때, 이 클라이언트는 이런 메소드의 변경에 취약하다. 이것은 모든 클라이언트 간의 의도하지 않은 결합을 불러일으킨다.

어떤 클라이언트가 자신은 사용하지 않지만 다른 클라이언트가 그 클래스에 가하는 변경에 영향을 받게 된다. 따라서 인터페이스를 분리하기를 원한다.



**"클린 소프트웨어" 를 참고하였습니다.**

